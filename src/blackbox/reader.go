package blackbox

import (
	"bufio"
	"bytes"
	"context"
	"io"

	"github.com/maxlaverse/blackbox-library/src/blackbox/stream"
	"github.com/pkg/errors"
)

const (
	defaultBufferSize = 8192
)

// FlightLogReader parses logs generated by the CleanFlight controller
type FlightLogReader struct {
	FrameDef LogDefinition
	Stats    *StatsType
	opts     FlightLogReaderOpts
}

// FlightLogReaderOpts holds the options to get a new FlightLogReader
type FlightLogReaderOpts struct {
	Raw bool
}

// NewFlightLogReader returns a new FlightLogReader
func NewFlightLogReader(opts FlightLogReaderOpts) *FlightLogReader {
	return &FlightLogReader{
		opts: opts,
	}
}

// LoadFile reads flight logs from a file.
// Accepts context and stops processing when the context is canceled.
// Returns channel with successfully parsed frames and channel with errors.
func (f *FlightLogReader) LoadFile(file io.Reader, ctx context.Context) (<-chan Frame, error) {
	frameReader, decoder, err := f.initFrameReader(file)
	if err != nil {
		return nil, err
	}

	frameChan := make(chan Frame)
	go func() {
		defer func() {
			close(frameChan)
		}()

		// collect stats when the process is done
		defer func() {
			f.Stats = frameReader.Stats
		}()

		for !frameReader.Finished {
			// check on every iteration if the context has been canceled and stop processing if so
			select {
			case <-ctx.Done():
				return
			default:
			}

			frame := frameReader.ReadNextFrame()
			// if the frame is corrupted - we should skip all bytes until the next frame
			if frame.Error() != nil {
				_, err = consumeToNext(decoder) // @TODO: consume skippedFrames value if needed
			}
			if err != nil {
				frame.setError(err)
			}

			// finally send the frame out
			frameChan <- frame

			// if there were any previous non-frame errors - stop immediately
			if err != nil {
				return
			}
		}
		err = nil
	}()

	return frameChan, nil
}

func (f *FlightLogReader) initFrameReader(file io.Reader) (*FrameReader, *stream.Decoder, error) {
	bufferedStream := bufio.NewReaderSize(file, defaultBufferSize)

	decoder := stream.NewDecoder(bufferedStream)
	headerReader := NewHeaderReader(decoder)
	frameDefinition, err := headerReader.ProcessHeaders()
	if err != nil {
		return nil, nil, err
	}

	f.FrameDef = frameDefinition

	opts := &FrameReaderOptions{
		Raw: f.opts.Raw,
	}
	frameReader, err := NewFrameReader(decoder, frameDefinition, opts)

	return frameReader, decoder, err
}

func consumeToNext(enc *stream.Decoder) (skippedFrames int64, err error) {
	initialPos := enc.BytesRead()
	for i := 0; i < 256; i++ {
		b, err := enc.NextByte()
		if err != nil {
			return 0, err
		}

		if bytes.IndexByte(LogFrameAllTypes, b) != -1 {
			newPos := enc.BytesRead()
			return newPos - initialPos, nil
		}

		_, err = enc.ReadByte()
		if err != nil {
			return 0, err
		}
	}

	return 0, errors.New("FlightLogReader: could not find next frame")
}
