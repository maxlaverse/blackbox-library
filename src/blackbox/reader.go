package blackbox

import (
	"bufio"
	"bytes"
	"github.com/pkg/errors"
	"io"

	"github.com/maxlaverse/blackbox-library/src/blackbox/stream"
)

const (
	defaultBufferSize = 8192
)

// FlightLogReader parses logs generated by the CleanFlight controller
type FlightLogReader struct {
	FrameDef LogDefinition
	Frames   []Frame
	opts     FlightLogReaderOpts
}

// FlightLogReaderOpts holds the options to get a new FlightLogReader
type FlightLogReaderOpts struct {
	Raw bool
}

// NewFlightLogReader returns a new FlightLogReader
func NewFlightLogReader(opts FlightLogReaderOpts) FlightLogReader {
	return FlightLogReader{
		opts: opts,
	}
}

// LoadFile reads a file
func (f *FlightLogReader) LoadFile(file io.Reader) error {
	bufferedStream := bufio.NewReaderSize(file, defaultBufferSize)

	decoder := stream.NewDecoder(bufferedStream)

	headerReader := NewHeaderReader(&decoder)
	frameDefinition, err := headerReader.ProcessHeaders()
	if err != nil {
		return err
	}

	f.FrameDef = frameDefinition

	opts := &FrameReaderOptions{
		Raw: false,
	}

	frameReader, err := NewFrameReader(&decoder, frameDefinition, opts)
	if err != nil {
		return err
	}

	for !frameReader.Finished {
		frame, err := frameReader.ReadNextFrame()
		if err == nil {
			f.Frames = append(f.Frames, frame)
			continue
		}

		// @TODO: consume skippedFrames
		_, err = consumeToNext(decoder)
		if err != nil {
			return err
		}
	}

	frameReader.PrintStatistics()
	return nil
}

func consumeToNext(enc stream.Decoder) (skippedFrames int64, err error) {
	initialPos := enc.BytesRead()
	for i := 0; i < 256; i++ {
		b, err := enc.NextByte()
		if err != nil {
			return 0, err
		}

		if bytes.IndexByte(LogFrameAllTypes, b) != -1 {
			newPos := enc.BytesRead()
			return newPos - initialPos, nil
		}

		_, err = enc.ReadByte()
		if err != nil {
			return 0, err
		}
	}

	return 0, errors.New("FlightLogReader: could not find next frame")
}
