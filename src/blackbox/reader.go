package blackbox

import (
	"bufio"
	"context"
	"io"
	"time"

	"github.com/maxlaverse/blackbox-library/src/blackbox/stream"
)

const (
	// Number of bytes for the buffered reader
	defaultBufferSize = 8192
)

// FlightLogReader parses logs generated by the CleanFlight controller
type FlightLogReader struct {
	FrameDef LogDefinition
	Stats    *LogStatistics
	opts     FlightLogReaderOpts
}

// FlightLogReaderOpts holds the options to get a new FlightLogReader
type FlightLogReaderOpts struct {
	Raw bool
}

// NewFlightLogReader returns a new FlightLogReader
func NewFlightLogReader(opts FlightLogReaderOpts) *FlightLogReader {
	return &FlightLogReader{
		opts: opts,
	}
}

// LoadFile reads flight logs from a file.
// Accepts context and stops processing when the context is canceled.
// Returns channel with successfully parsed frames.
func (f *FlightLogReader) LoadFile(ctx context.Context, file io.Reader) (<-chan Frame, error) {
	frameReader, err := f.initFrameReader(file)
	if err != nil {
		return nil, err
	}

	frameChan := make(chan Frame)
	go func() {
		f.Stats = readFrameToChannel(ctx, frameReader, frameChan)
	}()

	return frameChan, nil
}

func (f *FlightLogReader) initFrameReader(file io.Reader) (*FrameReader, error) {
	bufferedStream := bufio.NewReaderSize(file, defaultBufferSize)

	decoder := stream.NewDecoder(bufferedStream)
	headerReader := NewHeaderReader(decoder)
	frameDefinition, err := headerReader.ProcessHeaders()
	if err != nil {
		return nil, err
	}

	f.FrameDef = frameDefinition

	opts := &FrameReaderOptions{
		Raw: f.opts.Raw,
	}
	return NewFrameReader(decoder, frameDefinition, opts), nil
}

func readFrameToChannel(ctx context.Context, frameReader *FrameReader, frameChan chan Frame) *LogStatistics {
	defer close(frameChan)

	stats := NewLogStatistics()
	stats.HeaderBytes = int(frameReader.dec.Offset())

FrameReadingLoop:
	for {
		// check on every iteration if the context has been canceled and stop processing if so
		select {
		case <-ctx.Done():
			break FrameReadingLoop
		default:
		}

		// read the next frame
		frame := frameReader.ReadNextFrame()
		if frame.Error() == io.EOF {
			break
		}

		// update our start timestamp when we see the first intra frame
		if stats.Start.IsZero() && frame.Type() == LogFrameIntra {
			stats.Start = time.Unix(0, int64(frame.Values().([]int32)[1])*1000)
		}

		// update our end timestamp everytime we see a frame
		if frame.Type() == LogFrameIntra || frame.Type() == LogFrameInter {
			stats.End = time.Unix(0, int64(frame.Values().([]int32)[1])*1000)
		}

		// update some statistics
		stats.TotalFrames++
		stats.Bytes += frame.Size()
		if frame.Type() != 0 {
			stats.Frame[frame.Type()] = updatedFrameStatistics(frame, stats.Frame[frame.Type()])
		} else if frame.Error() != nil {
			stats.TotalCorruptedFrames++
			stats.CorruptedBytes += frame.Size()
		}

		frameChan <- frame
	}
	return stats
}

func updatedFrameStatistics(frame Frame, stats *FrameStatistics) *FrameStatistics {
	if frame.Error() != nil {
		stats.CorruptCount++
	} else {
		if frame.Validity() {
			stats.ValidCount++
		} else {
			stats.DesyncCount++
		}
		stats.Bytes += int64(frame.Size())
		if stats.SizeCount == nil {
			stats.SizeCount = map[int]int{}
		}
		stats.SizeCount[frame.Size()]++
	}
	return stats
}
